[toc]

# ⭐运算符

> 注意：请勿滥用运算符重载

## 多元运算符要左右空格

一般为算数，赋值等运算符

```cpp
// good
const int M = 1e9 + 7;
int arr[M] = {};
for (int i = 0; i < M; i += 1) {
    arr[i] = i & 1 ? i + M : i * M;
}

// bad
const int M=1e9+7;
int arr[M]={};
for (int i=0; i<M; i+=1) {
    arr[i]=i&1?i+M:i*M;
}
```

## 一元运算符要贴近变量

```cpp
// good
void fun(int *x, int &y) {
    *x = -1;
    y = ~*x;

    ++*x;
    y = !y;
}

// bad
void fun(int * x, int & y) {
    * x = - 1;
    y = ~ * x;

    ++ * x;
    y = ! y;
}
```

## 成员访问符号要贴近变量

一元或二元访问符都要求贴近变量

> 注意：在C++17前不保证左右的运算顺序

```cpp
// 一元
*a
&a
// 二元
a[b]
a.b
a->b
a.*b
a->*b
```

## 减少使用自增++和自减--

> 自增自减在一些语言中已经不支持，如：Python

**危害：**

- 自增，自减在混合运算中，在不同编译器中实现的效果是不一样的
- 使用宏定义时，可能会执行多次

| 自增/自减     | 替代                 |
| ------------- | -------------------- |
| `i++; / ++i;` | `i += 1;`            |
| `i--; / --i;` | `i += -1; / i -= 1;` |

## 使用括号增加可读性

在一些位运算，较长的逻辑判断时，应该增加括号来增加可读性和准确性。

实在过长则应该跨行来编写。

```cpp
// good
if ((a && (b + 1)) || ((c << d) | e)) {
}

// bad
if (a && b + 1 || c << d | e) {
}
```

## 比较运算符左侧尽量写常量

部分现代编译器和 ide 会有单等号的提示。且从左往右读更符合人的思考和阅读习惯。

因此如何能保证正确，则该条说明不强制，单前提是保证了正确。

```cpp
void* p;
int x;

// good
if (NULL == p) {
}
if (0 == x) {
}

// bad
// == 容易写成 =
if (p == NULL) {
}
if (x == 0) {
}
```

## 显示的布尔判断代替非0即1

**非0即1的危害：**

- 无法明示类型
- 会出现隐式类型转换

```cpp
// good
// 明示flag是一个布尔运算符 （虽然不绝对是）
if (true == flag) {
}

// bad
// 不明确类型
if (flag) {
}
```

## 运算符重载

- 时刻注意运算符重载的本质是函数的调用。
- 禁止滥用运算符重载
- 赋值运算符应与拷贝，移动构造的效果保持一致
- 慎用类型转换
- 禁止重载`&&||,`等运算符
- **TODO**

